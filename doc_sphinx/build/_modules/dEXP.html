<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dEXP &mdash; pydEXP v0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> pydEXP
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                v0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">pydEXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../content/started/getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/started/install.html">Which Python?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/started/install.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/started/install.html#optionnal-third-party-packages">Optionnal Third party packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/licence.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../content/authors.html">Authors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Thematic examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#gravimetric-potential-field-data">Gravimetric potential field data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#magnetic-potential-field-data">Magnetic potential field data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html#mise-a-la-masse-analysis-using-the-dexp-theory">Mise-Ã -la-masse analysis using the dEXP theory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../content/api_core/api.html">API reference: The <code class="docutils literal notranslate"><span class="pre">pydEXP</span></code> package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pydEXP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>dEXP</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dEXP</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Imaging methods for potential fields.</span>

<span class="sd">Implements the DEXP method described in Fedi and Pilkington (2012).</span>

<span class="sd">.. note::</span>

<span class="sd">    This is part of a larger project aiming at inverting current sources density (see more at: https://icsd-dev.readthedocs.io/en/latest/)</span>


<span class="sd">**References**</span>

<span class="sd">Fedi, M., and M. Pilkington (2012), Understanding imaging methods for potential</span>
<span class="sd">field data, Geophysics, 77(1), G13, doi:10.1190/geo2011-0078.1</span>

<span class="sd">----</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">pl</span>

<span class="kn">from</span> <span class="nn">fatiando.gravmag</span> <span class="kn">import</span> <span class="n">imaging</span><span class="p">,</span> <span class="n">transform</span>
<span class="kn">from</span> <span class="nn">fatiando.gravmag.imaging</span> <span class="kn">import</span> <span class="n">_makemesh</span>
<span class="kn">from</span> <span class="nn">fatiando</span> <span class="kn">import</span> <span class="n">gridder</span><span class="p">,</span> <span class="n">mesher</span><span class="p">,</span> <span class="n">utils</span>


<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">sproot</span><span class="p">,</span>
    <span class="n">CubicSpline</span><span class="p">,</span>
    <span class="n">UnivariateSpline</span><span class="p">,</span>
    <span class="n">InterpolatedUnivariateSpline</span><span class="p">,</span>
    <span class="n">BSpline</span><span class="p">,</span>
    <span class="n">LSQUnivariateSpline</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">find_peaks</span><span class="p">,</span>
    <span class="n">peak_prominences</span><span class="p">,</span>
    <span class="n">peak_widths</span><span class="p">,</span>
<span class="p">)</span>  <span class="c1"># useful for ridges detection</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="c1"># class DEXP():</span>


<div class="viewcode-block" id="ridges_minmax_plot"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.ridges_minmax_plot">[docs]</a><span class="k">def</span> <span class="nf">ridges_minmax_plot</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">p1</span><span class="p">,</span>
    <span class="n">p2</span><span class="p">,</span>
    <span class="n">qorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">fix_peak_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;upwc&quot;</span><span class="p">,</span>
    <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">showfig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    * x, y : 1D-arrays</span>
<span class="sd">        The x and y coordinates of the grid points</span>
<span class="sd">    * mesh : fatiando.mesher.PrismMesh</span>
<span class="sd">        The estimated physical property distribution set in a prism mesh (for easy 3D plotting)</span>
<span class="sd">    * p1, p2 : 1D-arrays</span>
<span class="sd">        The p1 and p2 coordinates of the extracted profile end points</span>
<span class="sd">    * qorder : int</span>
<span class="sd">        The derivative order</span>
<span class="sd">    * z : float or 1D-array</span>
<span class="sd">        The z coordinate of the grid points</span>
<span class="sd">    * fix_peak_nb : int</span>
<span class="sd">        The maximum number of peak to identify</span>
<span class="sd">    * label : string</span>
<span class="sd">        Label of the estimated physical property distribution</span>
<span class="sd">    * interp : True or False</span>
<span class="sd">        If True, will interpolate values between the data points.</span>
<span class="sd">    * smooth : True or False</span>
<span class="sd">        If True, will apply a low-pass filter values.</span>
<span class="sd">    * showfig : True or False</span>
<span class="sd">        If True, will display the figure.</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

    <span class="n">method_peak</span> <span class="o">=</span> <span class="s2">&quot;find_peaks&quot;</span>
    <span class="n">x_resolution</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Xaxis</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
    <span class="c1"># --------------------------------------------</span>
    <span class="c1"># parameters to parse into find_peaks function</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;fix_peak_nb&quot;</span><span class="p">:</span>
            <span class="n">fix_peak_nb</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;method_peak&quot;</span><span class="p">:</span>
            <span class="n">method_peak</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;x_resolution&quot;</span><span class="p">:</span>
            <span class="n">x_resolution</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;Xaxis&quot;</span><span class="p">:</span>
            <span class="n">Xaxis</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># prom = 0.1 #</span>
    <span class="c1"># fix_nb_peaks = 3</span>
    <span class="c1"># --------------------------------------------</span>

    <span class="c1"># This way, if z is not an array, it is now</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">RI_minmax</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># minmax of the first horizontal derivative of the potential field</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_zs</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">props</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mesh doesn&#39;t have a &#39;</span><span class="si">%s</span><span class="s2">&#39; property.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upw_u</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
    <span class="n">upw_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">upw_u</span><span class="p">,</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;reverse&quot;</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fix_peak_nb =&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="c1"># print(&quot;to test&quot;)</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">depths</span><span class="p">)</span>
            <span class="n">upw_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">upw_u</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># Loop for RII extremas</span>
        <span class="n">upw_u_l</span> <span class="o">=</span> <span class="n">upw_u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># analysing extrema layers by layers from top to bottom</span>
        <span class="c1"># 1st horizontal derivate of the continued field</span>
        <span class="c1"># up_f_d1x = transform.derivx(x, y, upw_u_l,(mesh.shape[1],mesh.shape[1]),order=1)</span>
        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Impossible to calculate the derivative in this profil direction&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">up_f_d1x</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivx</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_f_d1x</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivy</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">interp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">,</span> <span class="n">p_up_f_d1x_dict</span> <span class="o">=</span> <span class="n">profile_noInter</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">xx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">yy</span>

        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">p_up_f_d1x_dict</span><span class="p">[</span><span class="n">smooth</span><span class="p">]</span>

        <span class="c1"># if smooth == True:</span>
        <span class="c1">#     p_up_f_d1x = _smooth_lowpass(xaxis,p_up_f_d1x)</span>

        <span class="c1"># peak analysis</span>
        <span class="n">MinMax_peaks</span><span class="p">,</span> <span class="n">MinMax_peaks_p</span> <span class="o">=</span> <span class="n">_peaks_analysis</span><span class="p">(</span>
            <span class="n">xaxis</span><span class="p">,</span>
            <span class="n">p_up_f_d1x</span><span class="p">,</span>
            <span class="n">fix_peak_nb</span><span class="o">=</span><span class="n">fix_peak_nb</span><span class="p">,</span>
            <span class="n">method_peak</span><span class="o">=</span><span class="n">method_peak</span><span class="p">,</span>
            <span class="n">proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">depths</span><span class="p">)))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">depth</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span> <span class="n">p_up_f_d1x</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
                <span class="p">)</span>
                <span class="c1"># plt.scatter(MinMax_peaks[ind],0,color= &#39;r&#39;)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>


<div class="viewcode-block" id="ridges_minmax"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.ridges_minmax">[docs]</a><span class="k">def</span> <span class="nf">ridges_minmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">p1</span><span class="p">,</span>
    <span class="n">p2</span><span class="p">,</span>
    <span class="n">qorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;upwc&quot;</span><span class="p">,</span>
    <span class="n">fix_peak_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">showfig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Form a multiridge set</span>
<span class="sd">    RI and RII : zeros of the first horizontal and first vertical derivatives of the potential field</span>
<span class="sd">    RIII :zeros of the potential field itself</span>

<span class="sd">    .. note:: ridges generated by isolated simple sources point, line, sheet, and contact are straight lines defined by the zeros of a potential</span>
<span class="sd">    field and its horizontal and vertical derivatives at all measured or computed levels</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D-arrays</span>
<span class="sd">        The x and y coordinates of the grid points</span>
<span class="sd">    * mesh : fatiando.mesher.PrismMesh</span>
<span class="sd">        The estimated physical property distribution set in a prism mesh (for easy 3D plotting). The upward continuated field mesh (of order-q derivative).</span>
<span class="sd">        Read the property label &#39;upwc&#39; of the mesh by default</span>
<span class="sd">    * p1, p2 : 1D-arrays</span>
<span class="sd">        The p1 and p2 coordinates of the extracted profile end points</span>
<span class="sd">    * qorder : int</span>
<span class="sd">        The derivative order</span>
<span class="sd">    * z : float or 1D-array</span>
<span class="sd">        The z coordinate of the grid points</span>
<span class="sd">    * label : string</span>
<span class="sd">        Label of the estimated physical property distribution</span>
<span class="sd">    * fix_peak_nb : int</span>
<span class="sd">        The maximum number of peak to identify</span>
<span class="sd">    * interp : True or False</span>
<span class="sd">        If True, will interpolate values between the data points.</span>
<span class="sd">    * smooth : True or False</span>
<span class="sd">        If True, will apply a low-pass filter values.</span>
<span class="sd">    * showfig : True or False</span>
<span class="sd">        If True, will display the figure.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        prominence for peak detection</span>
<span class="sd">        reverse: start peak analysis from bottom to top</span>

<span class="sd">    Returns:</span>

<span class="sd">    * MinMax_peaks :</span>
<span class="sd">        Panda dataframe containing ridges RI, RII and RII</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># --------------------------------------------</span>
    <span class="c1"># parameters to parse into find_peaks function</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;fix_peak_nb&quot;</span><span class="p">:</span>
            <span class="n">fix_peak_nb</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># --------------------------------------------</span>

    <span class="c1"># This way, if z is not an array, it is now</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># indices of the peaks</span>
    <span class="n">RI_minmax</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># minmax of the first horizontal derivative of the potential field</span>
    <span class="n">RII_minmax</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># minmax of the first vertical derivative of the potential field</span>
    <span class="n">RIII_minmax</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># minmax of the potential field</span>

    <span class="c1"># dictionnary of the peaks properties</span>
    <span class="n">RI_minmax_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">RII_minmax_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">RIII_minmax_p</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># --------------------------------------------</span>
    <span class="c1"># select depths</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_zs</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_resolution</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Xaxis</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
    <span class="n">peakp_out</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">iplot</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;minAlt_ridge&quot;</span><span class="p">:</span>
            <span class="n">minAlt_ridge</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">depths</span> <span class="o">&gt;</span> <span class="n">minAlt_ridge</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;maxAlt_ridge&quot;</span><span class="p">:</span>
            <span class="n">maxAlt_ridge</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">depths</span> <span class="o">&lt;</span> <span class="n">maxAlt_ridge</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;method_peak&quot;</span><span class="p">:</span>
            <span class="n">method_peak</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;x_resolution&quot;</span><span class="p">:</span>
            <span class="n">x_resolution</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;Xaxis&quot;</span><span class="p">:</span>
            <span class="n">Xaxis</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;returnAmp&quot;</span><span class="p">:</span>
            <span class="n">peakp_out</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;iplot&quot;</span><span class="p">:</span>
            <span class="n">iplot</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># --------------------------------------------</span>

    <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">props</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mesh doesn&#39;t have a &#39;</span><span class="si">%s</span><span class="s2">&#39; property.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upw_u</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
    <span class="n">upw_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">upw_u</span><span class="p">,</span> <span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># Loop over RIII extremas</span>
        <span class="n">upw_u_l</span> <span class="o">=</span> <span class="n">upw_u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># analysing extrema layers by layers from top to bottom</span>

        <span class="k">if</span> <span class="n">interp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">,</span> <span class="n">p_up_f_dict</span> <span class="o">=</span> <span class="n">profile_noInter</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">xx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">yy</span>

        <span class="c1"># if smooth is not None:</span>
        <span class="c1">#     p_up_f = _smooth_lowpass(xaxis,p_up_f)</span>
        <span class="c1">#     p_up_f =</span>
        <span class="c1"># p_up_f = np.array(p_up_f)</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">p_up_f_d1z</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_up_f</span> <span class="o">=</span> <span class="n">p_up_f_dict</span><span class="p">[</span><span class="n">smooth</span><span class="p">]</span>
        <span class="n">p_up_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_up_f</span><span class="p">)</span>

        <span class="c1"># print(p_up_f)</span>

        <span class="c1"># peak analysis</span>
        <span class="n">MinMax_peaks</span><span class="p">,</span> <span class="n">MinMax_peaks_p</span> <span class="o">=</span> <span class="n">_peaks_analysis</span><span class="p">(</span>
            <span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">,</span> <span class="n">fix_peak_nb</span><span class="o">=</span><span class="n">fix_peak_nb</span><span class="p">,</span> <span class="n">method_peak</span><span class="o">=</span><span class="n">method_peak</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># RIII_minmax.append(np.hstack([[depth], MinMax_peaks]))</span>
            <span class="n">RIII_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">]]))</span>
            <span class="n">RIII_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">MinMax_peaks_p</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RIII_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="p">[]]))</span>
            <span class="n">RIII_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">MinMax_peaks_p</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">iplot</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span> <span class="n">p_up_f</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;g&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># plt.scatter([MinMax_peaks[ind]],0,color=&#39;g&#39;)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax_list</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
                <span class="n">ax_list</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># Loop over RII extremas</span>
        <span class="n">upw_u_l</span> <span class="o">=</span> <span class="n">upw_u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># analysing extrema layers by layers from top to bottom</span>

        <span class="c1"># 1st vertical derivate of the continued field</span>
        <span class="n">up_f_d1z</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivz</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">interp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1z</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1z</span><span class="p">,</span> <span class="n">p_up_f_d1z_dict</span> <span class="o">=</span> <span class="n">profile_noInter</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
            <span class="c1"># p_up_f_d1z = p_up_f_d1z_smooth</span>

        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">xx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">yy</span>

        <span class="c1"># if smooth == True:</span>
        <span class="c1">#     p_up_f_d1z = _smooth_lowpass(xaxis,p_up_f_d1z)</span>
        <span class="c1"># p_up_f = np.array(p_up_f)</span>

        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">p_up_f_d1z</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1z</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_up_f_d1z</span> <span class="o">=</span> <span class="n">p_up_f_d1z_dict</span><span class="p">[</span><span class="n">smooth</span><span class="p">]</span>

        <span class="c1"># peak analysis</span>
        <span class="n">MinMax_peaks</span><span class="p">,</span> <span class="n">MinMax_peaks_p</span> <span class="o">=</span> <span class="n">_peaks_analysis</span><span class="p">(</span>
            <span class="n">xaxis</span><span class="p">,</span>
            <span class="n">p_up_f_d1z</span><span class="p">,</span>
            <span class="n">fix_peak_nb</span><span class="o">=</span><span class="n">fix_peak_nb</span><span class="p">,</span>
            <span class="n">method_peak</span><span class="o">=</span><span class="n">method_peak</span><span class="p">,</span>
            <span class="n">proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># RII_minmax.append(np.hstack([[depth], MinMax_peaks]))</span>
            <span class="n">RII_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">]]))</span>
            <span class="n">RII_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">MinMax_peaks_p</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RII_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="p">[]]))</span>
            <span class="n">RII_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="p">[]]))</span>

        <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">iplot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1z</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;dz&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span>
                        <span class="n">p_up_f_d1z</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># plt.scatter([MinMax_peaks[ind]],0,color=&#39;g&#39;)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax_list</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
                <span class="n">ax_list</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>


    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># Loop for RII extremas</span>
        <span class="n">upw_u_l</span> <span class="o">=</span> <span class="n">upw_u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># analysing extrema layers by layers from top to bottom</span>
        <span class="c1"># 1st horizontal derivate of the continued field</span>

        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Impossible to calculate the derivative in this profil direction&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">up_f_d1x</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivx</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up_f_d1x</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivy</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_u_l</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">interp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">,</span> <span class="n">p_up_f_d1x_dict</span> <span class="o">=</span> <span class="n">profile_noInter</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">up_f_d1x</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x_resolution</span>
            <span class="p">)</span>
            <span class="c1"># p_up_f_d1x = p_up_f_d1x_smooth</span>

        <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">xx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xaxis</span> <span class="o">=</span> <span class="n">yy</span>

        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_up_f_d1x</span> <span class="o">=</span> <span class="n">p_up_f_d1x_dict</span><span class="p">[</span><span class="n">smooth</span><span class="p">]</span>

        <span class="c1"># peak analysis</span>
        <span class="n">MinMax_peaks</span><span class="p">,</span> <span class="n">MinMax_peaks_p</span> <span class="o">=</span> <span class="n">_peaks_analysis</span><span class="p">(</span>
            <span class="n">xaxis</span><span class="p">,</span>
            <span class="n">p_up_f_d1x</span><span class="p">,</span>
            <span class="n">fix_peak_nb</span><span class="o">=</span><span class="n">fix_peak_nb</span><span class="p">,</span>
            <span class="n">method_peak</span><span class="o">=</span><span class="n">method_peak</span><span class="p">,</span>
            <span class="n">proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">RI_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">]]))</span>
            <span class="n">RI_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="n">MinMax_peaks_p</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RI_minmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="p">[]]))</span>
            <span class="n">RI_minmax_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="n">depth</span><span class="p">],</span> <span class="p">[]]))</span>

        <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">iplot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">p_up_f_d1x</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;dx&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MinMax_peaks</span><span class="p">)):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                        <span class="n">xaxis</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span>
                        <span class="n">p_up_f_d1x</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">[</span><span class="n">ind</span><span class="p">]],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># plt.scatter([MinMax_peaks[ind]],0,color=&#39;g&#39;)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="c1"># R = [np.array(RI_minmax), np.array(RII_minmax), np.array(RIII_minmax)]</span>
    <span class="n">dfI</span><span class="p">,</span> <span class="n">dfII</span><span class="p">,</span> <span class="n">dfIII</span> <span class="o">=</span> <span class="n">_ridges_2_df</span><span class="p">(</span><span class="n">RI_minmax</span><span class="p">,</span> <span class="n">RII_minmax</span><span class="p">,</span> <span class="n">RIII_minmax</span><span class="p">)</span>
    <span class="n">dfIp</span><span class="p">,</span> <span class="n">dfIIp</span><span class="p">,</span> <span class="n">dfIIIp</span> <span class="o">=</span> <span class="n">_ridges_2_df</span><span class="p">(</span><span class="n">RI_minmax_p</span><span class="p">,</span> <span class="n">RII_minmax_p</span><span class="p">,</span> <span class="n">RIII_minmax_p</span><span class="p">)</span>
    <span class="c1"># R_fit = _build_ridge(RI_minmax,RII_minmax,RIII_minmax)</span>

    <span class="k">if</span> <span class="n">peakp_out</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dfI</span><span class="p">,</span> <span class="n">dfII</span><span class="p">,</span> <span class="n">dfIII</span><span class="p">,</span> <span class="n">ax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dfI</span><span class="p">,</span> <span class="n">dfII</span><span class="p">,</span> <span class="n">dfIII</span><span class="p">,</span> <span class="n">dfIp</span><span class="p">,</span> <span class="n">dfIIp</span><span class="p">,</span> <span class="n">dfIIIp</span><span class="p">,</span> <span class="n">ax</span> <span class="c1"># , R, R_fit</span></div>


<span class="k">def</span> <span class="nf">_peaks_analysis</span><span class="p">(</span>
    <span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">,</span> <span class="n">fix_peak_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method_peak</span><span class="o">=</span><span class="s2">&quot;spline_roots&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    search for peaks in the signal using a given algorithm defined by method_peak-</span>

<span class="sd">    .. note:: fix_peak_nb constrainst help to differentiate between main peaks and secondary peaks often required to exclude</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * x_axis : string</span>
<span class="sd">        The direction of the 2d profile</span>
<span class="sd">    * p_up_f : 1D-arrays</span>
<span class="sd">        Signal to analyse</span>
<span class="sd">    * fix_peak_nb : int</span>
<span class="sd">        Constrainst on number of peaks to detect</span>
<span class="sd">    * method_peak : string</span>
<span class="sd">        Constrainst on algoritm to use to detect the peaks</span>

<span class="sd">    **kwargs</span>
<span class="sd">        * showfig : True or False</span>
<span class="sd">            If True, will display the figure.</span>
<span class="sd">    Returns:</span>

<span class="sd">    * MinMax_peaks :</span>
<span class="sd">        numpy array containing min and max of peaks</span>
<span class="sd">    * p_up_f[MinMax_peaks]</span>
<span class="sd">        numpy array containing amplitude associated with the min and max of peaks</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;proxy&quot;</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span>
                <span class="n">pxy</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pxy</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">method_peak</span> <span class="o">==</span> <span class="s2">&quot;spline_roots&quot;</span><span class="p">:</span>
        <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">_spline_roots</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">method_peak</span> <span class="o">==</span> <span class="s2">&quot;find_peaks&quot;</span><span class="p">:</span>
            <span class="n">Max_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">prominences</span> <span class="o">=</span> <span class="n">peak_prominences</span><span class="p">(</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">Max_peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">results_half</span> <span class="o">=</span> <span class="n">peak_widths</span><span class="p">(</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">Max_peaks</span><span class="p">,</span> <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Max_peaks</span><span class="p">,</span> <span class="n">prominences</span><span class="p">,</span> <span class="n">results_half</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="k">if</span> <span class="n">p_max</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p_max</span> <span class="o">=</span> <span class="n">p_max</span><span class="p">[</span><span class="n">p_max</span><span class="p">[:,</span> <span class="n">pxy</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># --- repeat for the min --------</span>
            <span class="n">Min_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">p_up_f</span><span class="p">)</span>
            <span class="c1"># proxies to evaluate the peak</span>
            <span class="n">prominences</span> <span class="o">=</span> <span class="n">peak_prominences</span><span class="p">(</span><span class="o">-</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">Min_peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">results_half</span> <span class="o">=</span> <span class="n">peak_widths</span><span class="p">(</span><span class="o">-</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">Min_peaks</span><span class="p">,</span> <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">p_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Min_peaks</span><span class="p">,</span> <span class="n">prominences</span><span class="p">,</span> <span class="n">results_half</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="k">if</span> <span class="n">p_min</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">p_min</span> <span class="o">=</span> <span class="n">p_min</span><span class="p">[</span><span class="n">p_min</span><span class="p">[:,</span> <span class="n">pxy</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># MinMax_peaks= np.append(x_axis[Max_peaks],x_axis[Min_peaks])</span>
            <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Max_peaks</span><span class="p">,</span> <span class="n">Min_peaks</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fix_peak_nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">_select_ridges_nb</span><span class="p">(</span><span class="n">fix_peak_nb</span><span class="p">,</span> <span class="n">p_max</span><span class="p">,</span> <span class="n">p_min</span><span class="p">)</span>
            <span class="c1"># MinMax_peaks_p</span>
        <span class="k">elif</span> <span class="n">method_peak</span> <span class="o">==</span> <span class="s2">&quot;peakdet&quot;</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="n">Max_peaks</span><span class="p">,</span> <span class="n">Min_peaks</span> <span class="o">=</span> <span class="n">peakdet</span><span class="p">(</span><span class="n">p_up_f</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

            <span class="c1"># MinMax_peaks= np.append(x_axis[Max_peaks],x_axis[Min_peaks])</span>
            <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Max_peaks</span><span class="p">,</span> <span class="n">Min_peaks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MinMax_peaks</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">[</span><span class="n">MinMax_peaks</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_select_ridges_nb</span><span class="p">(</span><span class="n">fix_peak_nb</span><span class="p">,</span> <span class="n">p_max</span><span class="p">,</span> <span class="n">p_min</span><span class="p">):</span>

    <span class="c1"># print(&#39;_select_ridges_nb&#39;)</span>
    <span class="c1"># --- select a fixed number  --------</span>
    <span class="k">if</span> <span class="n">fix_peak_nb</span> <span class="o">&lt;</span> <span class="n">p_max</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">Max_peaks_select</span> <span class="o">=</span> <span class="n">p_max</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">fix_peak_nb</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Max_peaks_select</span> <span class="o">=</span> <span class="n">p_max</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">warn_peak</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">fix_peak_nb</span> <span class="o">&lt;</span> <span class="n">p_min</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">Min_peaks_select</span> <span class="o">=</span> <span class="n">p_min</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">fix_peak_nb</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p_min</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn_peak</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Min_peaks_select</span> <span class="o">=</span> <span class="n">p_min</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">warn_peak</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Min_peaks_select</span><span class="p">,</span> <span class="n">Max_peaks_select</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Max_peaks_select</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">MinMax_peaks</span>


<span class="k">def</span> <span class="nf">_spline_roots</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">):</span>

    <span class="n">spl</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up_f</span><span class="p">)</span>
    <span class="n">zeros_der</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>

    <span class="n">index_Max_peaks_der</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mpder</span> <span class="ow">in</span> <span class="n">zeros_der</span><span class="p">:</span>
        <span class="n">index_Max_peaks_der</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x_axis</span> <span class="o">-</span> <span class="n">mpder</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">())</span>

    <span class="n">MinMax_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zeros_der</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MinMax_peaks</span>


<span class="k">def</span> <span class="nf">_connect_ridges_lines</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">max_distances</span><span class="p">,</span> <span class="n">gap_thresh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify ridges in the 2D matrix. Expect that the width of</span>
<span class="sd">    the wavelet feature increases with increasing row number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matr: 2-D ndarray</span>
<span class="sd">        Matrix in which to identify ridge lines.</span>
<span class="sd">    max_distances: 1-D sequence</span>
<span class="sd">        At each row, a ridge line is only connected</span>
<span class="sd">        if the relative max at row[n] is within</span>
<span class="sd">        `max_distances`[n] from the relative max at row[n+1].</span>
<span class="sd">    gap_thresh: int</span>
<span class="sd">        If a relative maximum is not found within `max_distances`,</span>
<span class="sd">        there will be a gap. A ridge line is discontinued if</span>
<span class="sd">        there are more than `gap_thresh` points without connecting</span>
<span class="sd">        a new relative maximum.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ridge_lines: tuple</span>
<span class="sd">        tuple of 2 1-D sequences. `ridge_lines`[ii][0] are the rows of the ii-th</span>
<span class="sd">        ridge-line, `ridge_lines`[ii][1] are the columns. Empty if none found.</span>
<span class="sd">        Each ridge-line will be sorted by row (increasing), but the order</span>
<span class="sd">        of the ridge lines is not specified</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bioinformatics (2006) 22 (17): 2059-2065.</span>
<span class="sd">    doi: 10.1093/bioinformatics/btl355</span>
<span class="sd">    http://bioinformatics.oxfordjournals.org/content/22/17/2059.long</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = np.random.rand(5,5)</span>
<span class="sd">    &gt;&gt;&gt; ridge_lines = identify_ridge_lines(data, 1, 1)</span>

<span class="sd">    Notes:</span>
<span class="sd">    ------</span>
<span class="sd">    This function is intended to be used in conjuction with `cwt`</span>
<span class="sd">    as part of find_peaks_cwt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># -----------------------------------------------------------------------#</span>
    <span class="c1"># check ridge position consistency - create a new collumn if necessary</span>
    <span class="c1"># dfI_2add = []</span>
    <span class="c1"># for k in enumerate(dfI.columns[1:]): # loop over ridges of the same familly</span>
    <span class="c1">#     # check presence of drop</span>
    <span class="c1">#     diff_test = np.diff(dfI[k[1]])</span>
    <span class="c1">#     print(diff_test)</span>
    <span class="c1">#     broken_ridge = np.where(abs(diff_test)&gt; 5*abs(np.mean(np.diff(dfI[k[1]]))))[0]</span>
    <span class="c1">#     icol_max = len(dfI[k[1]])</span>
    <span class="c1">#     for b_r in enumerate(broken_ridge):</span>
    <span class="c1">#         dfI_new = dfI[k[1]][b_r[1]+1:-1]</span>
    <span class="c1">#         # dfI_new.add_prefix(&#39;EX_xpos&#39;)</span>
    <span class="c1">#         # dfI = dfI.drop(dfI[k[1]].index[b_r[1]+1:-1])</span>
    <span class="c1">#     dfI_2add.append(dfI_new)</span>

    <span class="c1">#     # build new ridge collumn</span>
    <span class="c1">#     dfI_new =</span>
    <span class="c1">#     dfI[]</span>
    <span class="c1">#     dfI = pd.DataFrame(RI_minmax)</span>
    <span class="c1">#     dfI = dfI.add_prefix(&#39;EX_xpos&#39;)</span>


<div class="viewcode-block" id="filter_ridges"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.filter_ridges">[docs]</a><span class="k">def</span> <span class="nf">filter_ridges</span><span class="p">(</span>
    <span class="n">dfIf</span><span class="p">,</span> <span class="n">dfIIf</span><span class="p">,</span> <span class="n">dfIIIf</span><span class="p">,</span> <span class="n">minDepth</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rmvNaN</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter non-rectiligne ridges (denoising)</span>

<span class="sd">    Parameters:</span>
<span class="sd">    dfI: dataframe</span>
<span class="sd">        contains ridges of type I</span>
<span class="sd">    dfII: dataframe</span>
<span class="sd">        contains ridges of type II</span>
<span class="sd">    dfIII: dataframe</span>
<span class="sd">        contains ridges of type III</span>
<span class="sd">    * minDepth</span>
<span class="sd">        Text here</span>
<span class="sd">    * maxDepth</span>
<span class="sd">    * kwargs</span>
<span class="sd">    heights: dataframe</span>
<span class="sd">        contains heights of ridges of type I</span>


<span class="sd">    Returns:</span>

<span class="sd">    * BB :</span>
<span class="sd">        Text here</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">height1f</span><span class="p">,</span> <span class="n">height2f</span><span class="p">,</span> <span class="n">height3f</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;heights&quot;</span><span class="p">:</span>
            <span class="n">height1f</span><span class="p">,</span> <span class="n">height2f</span><span class="p">,</span> <span class="n">height3f</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># print(height2)</span>
    <span class="c1"># -----------------------------------------------------------------------#</span>
    <span class="c1"># select a range of ridges within x limits</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;xmin&quot;</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">)</span>
                <span class="n">dfIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height1f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">)</span>
                <span class="n">dfIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height2f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height2f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">)</span>
                <span class="n">dfIIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height3f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height3f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;xmax&quot;</span><span class="p">:</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">)</span>
                <span class="n">dfIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height1f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">)</span>
                <span class="n">dfIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height2f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height2f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">dfIIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
                <span class="n">id_2NaN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dfIIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">)</span>
                <span class="n">dfIIIf</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">height3f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">height3f</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">id_2NaN</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># -----------------------------------------------------------------------#</span>
    <span class="c1"># remove lines NaN (produce when a peak defined only for some elevation levels)</span>
    <span class="k">if</span> <span class="n">rmvNaN</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dfIf</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NaN or Inf detected - trying to remove&quot;</span><span class="p">)</span>
            <span class="n">dfIf</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
            <span class="n">dfIf</span> <span class="o">=</span> <span class="n">dfIf</span><span class="p">[</span><span class="o">~</span><span class="n">dfIf</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># remove lines</span>

            <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">height1f</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
                <span class="n">height1f</span> <span class="o">=</span> <span class="n">height1f</span><span class="p">[</span>
                    <span class="o">~</span><span class="n">height1f</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># remove lines</span>

        <span class="k">if</span> <span class="n">dfIIf</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">dfIIf</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
            <span class="n">dfIIf</span> <span class="o">=</span> <span class="n">dfIIf</span><span class="p">[</span><span class="o">~</span><span class="n">dfIIf</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># remove lines</span>

            <span class="k">if</span> <span class="n">height2f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># print(height2)</span>
                <span class="n">height2f</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
                <span class="n">height2f</span> <span class="o">=</span> <span class="n">height2f</span><span class="p">[</span>
                    <span class="o">~</span><span class="n">height2f</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># remove lines</span>
                <span class="c1"># print(height2)</span>

        <span class="k">if</span> <span class="n">dfIIIf</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">dfIIIf</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
            <span class="n">dfIIIf</span> <span class="o">=</span> <span class="n">dfIIIf</span><span class="p">[</span>
                <span class="o">~</span><span class="n">dfIIIf</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>  <span class="c1"># remove lines</span>

            <span class="k">if</span> <span class="n">height3f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">height3f</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
                <span class="n">height3f</span> <span class="o">=</span> <span class="n">height3f</span><span class="p">[</span>
                    <span class="o">~</span><span class="n">height3f</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># remove lines</span>

    <span class="c1"># -----------------------------------------------------------------------#</span>
    <span class="c1"># regional filtering between two elevations.</span>
    <span class="c1"># Particulary useful to remove noise for data close to the surface</span>
    <span class="k">if</span> <span class="n">dfIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dfIf</span> <span class="o">=</span> <span class="n">dfIf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">dfIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dfIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height1f</span> <span class="o">=</span> <span class="n">height1f</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="p">(</span><span class="n">height1f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">height1f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)</span>
            <span class="p">]</span>

    <span class="k">if</span> <span class="n">dfIIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dfIIf</span> <span class="o">=</span> <span class="n">dfIIf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">dfIIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dfIIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">height2f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height2f</span> <span class="o">=</span> <span class="n">height2f</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="p">(</span><span class="n">height2f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">height2f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)</span>
            <span class="p">]</span>

    <span class="k">if</span> <span class="n">dfIIIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dfIIIf</span> <span class="o">=</span> <span class="n">dfIIIf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="p">(</span><span class="n">dfIIIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dfIIIf</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">height3f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height3f</span> <span class="o">=</span> <span class="n">height3f</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="p">(</span><span class="n">height3f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDepth</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">height3f</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">maxDepth</span><span class="p">)</span>
            <span class="p">]</span>

    <span class="c1"># -----------------------------------------------------------------------#</span>
    <span class="c1"># check length of ridges (remove column if less than N points)</span>
    <span class="k">if</span> <span class="n">dfIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smallCol</span> <span class="o">=</span> <span class="n">dfIf</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">idrmv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">smallCol</span> <span class="o">&lt;</span> <span class="n">minlength</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dfIf</span> <span class="o">=</span> <span class="n">dfIf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">dfIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height1f</span> <span class="o">=</span> <span class="n">height1f</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">height1f</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dfIIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smallCol</span> <span class="o">=</span> <span class="n">dfIIf</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">idrmv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">smallCol</span> <span class="o">&lt;</span> <span class="n">minlength</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dfIIf</span> <span class="o">=</span> <span class="n">dfIIf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">dfIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height2f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height2f</span> <span class="o">=</span> <span class="n">height2f</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">height2f</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dfIIIf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smallCol</span> <span class="o">=</span> <span class="n">dfIIIf</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">idrmv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">smallCol</span> <span class="o">&lt;</span> <span class="n">minlength</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dfIIIf</span> <span class="o">=</span> <span class="n">dfIIIf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">dfIIIf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">height3f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height3f</span> <span class="o">=</span> <span class="n">height3f</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">height3f</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idrmv</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">height1f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dfIf</span><span class="p">,</span> <span class="n">dfIIf</span><span class="p">,</span> <span class="n">dfIIIf</span><span class="p">,</span> <span class="n">height1f</span><span class="p">,</span> <span class="n">height2f</span><span class="p">,</span> <span class="n">height3f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dfIf</span><span class="p">,</span> <span class="n">dfIIf</span><span class="p">,</span> <span class="n">dfIIIf</span></div>


<div class="viewcode-block" id="fit_ridges"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.fit_ridges">[docs]</a><span class="k">def</span> <span class="nf">fit_ridges</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">rmvOutliers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit ridges and return points and fit equations to plot</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * df</span>
<span class="sd">        dataframe including all tree types of ridges</span>

<span class="sd">    Returns:</span>

<span class="sd">    * BB :</span>
<span class="sd">        points and fit equations to plot</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data to fit&quot;</span><span class="p">)</span>

    <span class="n">df_Rfit</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r_type</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)):</span>  <span class="c1"># loop over ridges type I, II, III</span>
        <span class="n">fit_ridges_all</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lable</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">):</span>  <span class="c1"># loop over ridges of the same familly</span>
            <span class="c1"># if abs(np.mean(np.diff(df[r_type][k[1]])))&gt;1: # check if ridge is vertical</span>
            <span class="c1"># print(df[r_type].columns[1:])</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>  <span class="c1"># slope sign</span>
            <span class="n">slope</span> <span class="o">=</span>  <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="s2">&quot;elevation&quot;</span><span class="p">])</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="s2">&quot;elevation&quot;</span><span class="p">]))</span>
            <span class="c1"># print(sign)</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># check if ridge is vertical</span>
                <span class="c1"># print( abs(np.mean(np.diff(df[r_type][k[1]]))))</span>
                <span class="c1"># if abs(np.mean(np.diff(df[r_type][k[1]])))&gt;1: # check if ridge is vertical</span>
                <span class="c1"># print(&quot;vertical ridge type:&quot; + str(r_type) + &quot; / ridgenb:&quot; + k[1])</span>
                <span class="n">fit_name</span> <span class="o">=</span> <span class="s2">&quot;R&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r_type</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; Vert.&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="s2">&quot;elevation&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="s2">&quot;elevation&quot;</span><span class="p">]),</span> <span class="mi">100</span>
                <span class="p">)</span>
                <span class="n">x_fit</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_fit</span><span class="p">))</span>
                <span class="c1"># print(x_fit,y_fit)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print(&quot;oblique ridge type:&quot; + str(r_type) + &quot; / ridgenb:&quot; + k[1])</span>
                <span class="n">fit_name</span> <span class="o">=</span> <span class="s2">&quot;R&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r_type</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; Obl.&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>



                <span class="n">x_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># print(x_values)</span>
                <span class="c1"># print(x_max)</span>
                <span class="c1"># print(x_min)</span>
                <span class="n">y_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span>
                <span class="c1"># print(x_values)</span>
                <span class="c1"># objective function</span>
                <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                	<span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

                <span class="c1"># fit curve</span>
                <span class="n">popt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)</span>

                <span class="c1"># define new input values</span>
                <span class="n">x_new</span><span class="o">=</span><span class="n">x_values</span>
                <span class="c1"># unpack optima parameters for the objective function</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">popt</span>
                <span class="c1"># use optimal parameters to calculate new values</span>
                <span class="n">y_new</span> <span class="o">=</span> <span class="n">objective</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

                <span class="c1"># x_fit, y_fit, _ = _fit(</span>
                <span class="c1">#     df[r_type][k[1]],</span>
                <span class="c1">#     df[r_type][&quot;elevation&quot;],</span>
                <span class="c1">#     slope=sign,</span>
                <span class="c1">#     rmvOutliers=rmvOutliers,</span>
                <span class="c1"># )  # fit function</span>

                <span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span>
                <span class="c1"># print(a)</span>

                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>  <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">r_type</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="mi">10</span>


                <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span><span class="n">x_max</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
                <span class="c1"># # use optimal parameters to calculate new values</span>
                <span class="n">y_new</span> <span class="o">=</span> <span class="n">objective</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

                <span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span>

                <span class="c1"># x_fit = df[r_type][k[1]]</span>
                <span class="c1"># y_fit = slope*x_fit #- min(df[r_type][k[1]])</span>
                <span class="c1"># plt.plot(df[r_type][k[1]].to_numpy(), m*xx + c, &#39;r&#39;, label=&#39;Fitted line&#39;)</span>
            <span class="c1"># plt.figure()</span>
            <span class="c1"># plt.title(r_type)</span>
            <span class="c1"># plt.plot(x_fit, y_fit, &#39;--&#39;)</span>
            <span class="c1"># plt.plot(df[r_type][k[1]],df[r_type][&#39;elevation&#39;], &#39;b*&#39;)</span>
            <span class="c1"># print(len(x_fit))</span>

            <span class="n">fit_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">lable_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
            <span class="n">lable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fit_name</span><span class="p">])</span>

            <span class="n">cols</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">lable</span><span class="p">,</span> <span class="n">lable_xy</span><span class="p">])</span>
            <span class="n">fit_tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fit_xy</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fit_ridges_all</span> <span class="o">=</span> <span class="n">fit_tmp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fit_ridges_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">fit_ridges_all</span><span class="p">,</span> <span class="n">fit_tmp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">df_Rfit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_ridges_all</span><span class="p">)</span>  <span class="c1"># merge ridges from different fanilly</span>

    <span class="k">return</span> <span class="n">df_Rfit</span></div>


<div class="viewcode-block" id="ridges_intersection_Z0"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.ridges_intersection_Z0">[docs]</a><span class="k">def</span> <span class="nf">ridges_intersection_Z0</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ridge_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find intersection of ridges (NOT YET IMPLEMENTED)</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * a</span>
<span class="sd">        Text here</span>

<span class="sd">    Returns:</span>

<span class="sd">    * BB :</span>
<span class="sd">        return intersection by pairs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://stackoverflow.com/questions/28766692/intersection-of-two-graphs-in-python-find-the-x-value</span>
    <span class="c1"># if ax == None:</span>
    <span class="c1">#     fig = plt.subplots()</span>
    <span class="c1">#     ax = plt.gca()</span>
    <span class="c1"># plt.rcParams[&#39;font.size&#39;] = 15</span>

    <span class="c1"># my_list = [1,2,3,4]</span>
    <span class="c1"># for pair in itertools.combinations(ridge_nb, r=2):</span>
    <span class="c1">#     print(pair)</span>

    <span class="c1"># if ridge_nb is None:</span>
    <span class="c1">#     ridge_nb = np.arange(0,len(fit))</span>

    <span class="c1"># for i in enumerate(ridge_nb):</span>

    <span class="c1">#     idx = np.argwhere(np.diff(np.sign(f - g))).flatten()</span>
    <span class="c1">#     plt.plot(x[idx], f[idx], &#39;ro&#39;)</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="scalFUN"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.scalFUN">[docs]</a><span class="k">def</span> <span class="nf">scalFUN</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">EXTnb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analysis of ridges (NOT YET IMPLEMENTED)</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * a</span>
<span class="sd">        Text here</span>

<span class="sd">    Returns:</span>

<span class="sd">    * BB :</span>
<span class="sd">        Text here</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rmvOutliers</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">rmvOutliers</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">SI</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">FIT</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">PT</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NaN or Inf detected - better to filter data first!&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># remove collumns</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># remove lines</span>

        <span class="c1"># Tau = np.gradient(np.log(up_f_Centralridge)) / np.gradient(np.log(z_r))</span>

    <span class="c1"># for i in enumerate(EXTnb):</span>
    <span class="c1"># for i in EXTnb:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">EXTnb</span>

    <span class="k">if</span> <span class="n">rmvOutliers</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># _ , filtered_entries, quartileSet = _removeOutliers(df[&#39;EX_xpos&#39;+str(i[1])])</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">filtered_entries</span><span class="p">,</span> <span class="n">quartileSet</span> <span class="o">=</span> <span class="n">_removeOutliers</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># print(&quot;------&quot;)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">filtered_entries</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># print(df[&#39;EX_xpos&#39;+str(i[1])])</span>
    <span class="c1"># num = np.gradient(np.log(np.abs(df[&#39;EX_xpos&#39;+str(i[1])])))</span>

    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(np.log(np.abs(df[i])))</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]))</span>
    <span class="c1"># print(&#39;num&#39;)</span>
    <span class="c1"># print(num)</span>

    <span class="c1"># plt.figure()</span>
    <span class="c1"># # plt.scatter(np.log(df[&#39;elevation&#39;]),np.log(np.abs(df[i])))</span>
    <span class="c1"># plt.scatter(np.log(1/df[&#39;elevation&#39;]),np.log(np.abs(df[i])))</span>
    <span class="c1"># plt.xlabel(&#39;log (1/z)&#39;)</span>
    <span class="c1"># plt.ylabel(&#39;log (ridge amplitude)&#39;)</span>

    <span class="c1"># print(den)</span>
    <span class="n">Tau</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="c1"># print(df[i])</span>

    <span class="c1"># dzz = np.log(df[1][&#39;elevation&#39;].iloc[1])-np.log(df[0][&#39;elevation&#39;].iloc[0])</span>
    <span class="n">Tau2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]))</span>
    <span class="c1"># Tau2 = np.gradient(np.log(np.abs(df[i])),4.2)</span>
    <span class="c1"># print(&#39;Tau&#39;)</span>
    <span class="c1"># print(Tau)</span>
    <span class="c1"># print(&#39;Tau2&#39;)</span>
    <span class="c1"># print(Tau2)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span>

    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">z0</span><span class="p">)</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span>
    <span class="c1"># factor = df[&#39;elevation&#39;]/(df[&#39;elevation&#39;] - z0)</span>
    <span class="c1"># factor = 1/(z0)</span>
    <span class="c1"># factor = 1</span>
    <span class="n">Tau</span> <span class="o">=</span> <span class="n">Tau2</span> <span class="o">*</span> <span class="n">factor</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">,</span> <span class="n">Tau</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">x_fit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">si</span> <span class="o">=</span> <span class="n">_fit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">SI</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_fit</span><span class="p">,</span> <span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="n">FIT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
    <span class="n">PT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">SI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PT</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FIT</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SI</span><span class="p">),</span> <span class="n">EXTnb</span></div>


<div class="viewcode-block" id="scalEULER"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.scalEULER">[docs]</a><span class="k">def</span> <span class="nf">scalEULER</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">EXTnb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analysis (Euler deconvolution of ridges, Fedi 2019) (NOT YET IMPLEMENTED)</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * a</span>
<span class="sd">        Text here</span>

<span class="sd">    Returns:</span>

<span class="sd">    * BB :</span>
<span class="sd">        Text here</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">fit</span>  <span class="c1"># , SI</span></div>


<div class="viewcode-block" id="upwc"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.upwc">[docs]</a><span class="k">def</span> <span class="nf">upwc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">qorder</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upward continuation model (Fedi, 2012).</span>

<span class="sd">    Calculates the upward continuation for given potential field data on a</span>
<span class="sd">    **regular grid**.</span>
<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D-arrays</span>
<span class="sd">        The x and y coordinates of the grid points</span>
<span class="sd">    * z : float or 1D-array</span>
<span class="sd">        The z coordinate of the grid points</span>
<span class="sd">    * data : 1D-array</span>
<span class="sd">        The potential field at the grid points</span>
<span class="sd">    * shape : tuple = (ny, nx)</span>
<span class="sd">        The shape of the grid</span>
<span class="sd">    * zmin, zmax : float</span>
<span class="sd">        The top and bottom, respectively, of the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * nlayers : int</span>
<span class="sd">        The number of layers used to divide the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * qorder : float</span>
<span class="sd">        The order of the vertical derivative</span>

<span class="sd">    Returns:</span>

<span class="sd">    * mesh : :class:`fatiando.mesher.PrismMesh`</span>
<span class="sd">        The estimated physical property distribution set in a prism mesh (for</span>
<span class="sd">        easy 3D plotting)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">_makemesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zmin</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># avoid downward continuation</span>
        <span class="n">zmin</span> <span class="o">=+</span> <span class="mf">1e-3</span>
    <span class="c1"># This way, if z is not an array, it is now</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Remove the last z because I only want depths to the top of the layers</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">get_zs</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">upw_f</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upw_f_dq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Offset by the data z because in the paper the data is at z=0</span>
    <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

        <span class="c1"># continued field calculation</span>
        <span class="n">upw_fhi</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">upcontinue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>

        <span class="c1"># qorder vertical derivate of the continued field</span>
        <span class="n">upw_f_dqhi</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_fhi</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">qorder</span><span class="p">)</span>

        <span class="c1"># print(np.mean(upw_fhi))</span>
        <span class="c1"># print(np.mean(upw_f_dqhi))</span>


        <span class="n">upw_f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">upw_fhi</span><span class="p">)</span>
        <span class="n">upw_f_dq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">upw_f_dqhi</span><span class="p">)</span>

    <span class="n">label_prop</span> <span class="o">=</span> <span class="s2">&quot;upwc_q&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">qorder</span><span class="p">)</span>
    <span class="c1"># mesh.addprop(&#39;upwc&#39;, np.array(upw_f))</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">addprop</span><span class="p">(</span><span class="n">label_prop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upw_f_dq</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">label_prop</span></div>


<div class="viewcode-block" id="dEXP"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.dEXP">[docs]</a><span class="k">def</span> <span class="nf">dEXP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">qorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">SI</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEXP model (Fedi, 2012). (NOT YET TESTED)</span>

<span class="sd">    Calculates a physical property distribution given potential field data on a</span>
<span class="sd">    **regular grid**. Uses depth weights.</span>
<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D-arrays</span>
<span class="sd">        The x and y coordinates of the grid points</span>
<span class="sd">    * z : float or 1D-array</span>
<span class="sd">        The z coordinate of the grid points</span>
<span class="sd">    * data : 1D-array</span>
<span class="sd">        The potential field at the grid points</span>
<span class="sd">    * shape : tuple = (ny, nx)</span>
<span class="sd">        The shape of the grid</span>
<span class="sd">    * zmin, zmax : float</span>
<span class="sd">        The top and bottom, respectively, of the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * nlayers : int</span>
<span class="sd">        The number of layers used to divide the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * qorder : float</span>
<span class="sd">        The order of the vertical derivative</span>
<span class="sd">    * SI : float</span>
<span class="sd">        The structural index</span>

<span class="sd">    Returns:</span>

<span class="sd">    * mesh : :class:`fatiando.mesher.PrismMesh`</span>
<span class="sd">        The estimated physical property distribution set in a prism mesh (for</span>
<span class="sd">        easy 3D plotting)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_dexp</span> <span class="o">=</span> <span class="n">_makemesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">)</span>
    <span class="c1"># This way, if z is not an array, it is now</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Remove the last z because I only want depths to the top of the layers</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="n">mesh_dexp</span><span class="o">.</span><span class="n">get_zs</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">depths</span><span class="p">))</span> <span class="o">**</span> <span class="p">((</span><span class="n">SI</span> <span class="o">+</span> <span class="n">qorder</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">csd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Offset by the data z because in the paper the data is at z=0</span>
    <span class="k">for</span> <span class="n">depth</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weights</span><span class="p">):</span>

        <span class="c1"># continued field calculation</span>
        <span class="n">upw_f</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">upcontinue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>

        <span class="c1"># qorder vertical derivate of the continued field</span>
        <span class="n">upw_f_dq</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_f</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">qorder</span><span class="p">)</span>

        <span class="c1"># the continued field weigted (=DEXP)</span>
        <span class="n">upw_f_dq_w</span> <span class="o">=</span> <span class="n">upw_f_dq</span> <span class="o">*</span> <span class="n">weight</span>
        <span class="n">csd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">upw_f_dq_w</span><span class="p">)</span>

    <span class="n">label_prop</span> <span class="o">=</span> <span class="s2">&quot;dexp_q&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">qorder</span><span class="p">)</span>
    <span class="n">mesh_dexp</span><span class="o">.</span><span class="n">addprop</span><span class="p">(</span><span class="n">label_prop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">csd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mesh_dexp</span><span class="p">,</span> <span class="n">label_prop</span></div>


<div class="viewcode-block" id="dEXP_ratio"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.dEXP_ratio">[docs]</a><span class="k">def</span> <span class="nf">dEXP_ratio</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">qorders</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">returnField</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEXP ratio model (NOT YET validated)</span>
<span class="sd">    Abbas, M. A., and Fedi, M. (2014). Automatic DEXP</span>
<span class="sd">    imaging of potential fields independent of the structural index. Geophysical Journal</span>
<span class="sd">    International, 199 (3), 1625-1632.</span>

<span class="sd">    Calculates a physical property distribution given potential field data on a</span>
<span class="sd">    **regular grid**. Uses depth weights.</span>
<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D-arrays</span>
<span class="sd">        The x and y coordinates of the grid points</span>
<span class="sd">    * z : float or 1D-array</span>
<span class="sd">        The z coordinate of the grid points</span>
<span class="sd">    * data : 1D-array</span>
<span class="sd">        The potential field at the grid points</span>
<span class="sd">    * shape : tuple = (ny, nx)</span>
<span class="sd">        The shape of the grid</span>
<span class="sd">    * zmin, zmax : float</span>
<span class="sd">        The top and bottom, respectively, of the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * nlayers : int</span>
<span class="sd">        The number of layers used to divide the region where the physical</span>
<span class="sd">        property distribution is calculated</span>
<span class="sd">    * qorders : 1D-array</span>
<span class="sd">        The order of the derivatives for the ratio calculation</span>

<span class="sd">    Returns:</span>

<span class="sd">    * mesh : :class:`fatiando.mesher.PrismMesh`</span>
<span class="sd">        The estimated physical property distribution set in a prism mesh (for</span>
<span class="sd">        easy 3D plotting)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_dexp</span> <span class="o">=</span> <span class="n">_makemesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">nlayers</span><span class="p">)</span>
    <span class="c1"># This way, if z is not an array, it is now</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Remove the last z because I only want depths to the top of the layers</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="n">mesh_dexp</span><span class="o">.</span><span class="n">get_zs</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">depths</span><span class="p">))</span> <span class="o">**</span> <span class="p">((</span><span class="n">qorders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">qorders</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">csd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Offset by the data z because in the paper the data is at z=0</span>
    <span class="k">for</span> <span class="n">depth</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">depths</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weights</span><span class="p">):</span>

        <span class="c1"># continued field calculation</span>
        <span class="n">upw_f</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">upcontinue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>

        <span class="c1"># qorder vertical derivate of the continued field</span>
        <span class="n">upw_f_dq_0</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_f</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">qorders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">upw_f_dq_1</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">derivz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">upw_f</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">qorders</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># upw_f_dq_0 = transform.derivy(x, y, upw_f, shape, order=qorders[0])</span>
        <span class="c1"># upw_f_dq_1 = transform.derivy(x, y, upw_f, shape, order=qorders[1])</span>
        
        
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">upw_f_dq_0</span> <span class="o">/</span> <span class="n">upw_f_dq_1</span>
        <span class="c1"># the continued field weigted (=DEXP)</span>
        <span class="n">upw_f_dq_w</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">ratio</span>
        <span class="c1"># upw_f_dq_w =  ratio</span>
        <span class="n">csd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">upw_f_dq_w</span><span class="p">)</span>

    <span class="n">label_prop</span> <span class="o">=</span> <span class="s2">&quot;dexp_q&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">qorders</span><span class="p">)</span>
    <span class="n">mesh_dexp</span><span class="o">.</span><span class="n">addprop</span><span class="p">(</span><span class="n">label_prop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">csd</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">returnField</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_dexp</span><span class="p">,</span> <span class="n">label_prop</span><span class="p">,</span> <span class="n">upw_f_dq_0</span><span class="p">,</span> <span class="n">upw_f_dq_1</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">upw_f_dq_w</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh_dexp</span><span class="p">,</span> <span class="n">label_prop</span></div>




<span class="c1"># def auto_dEXP():</span>
<span class="k">def</span> <span class="nf">_jumpAnalysis</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Get forward and backward derivatives (their absolute value as we care about magnitude of differences not direction):</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">largest_jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>

    <span class="n">jump</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">d1</span><span class="p">[</span><span class="n">largest_jumps</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
        <span class="n">jump</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">largest_jumps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jump</span>


<span class="k">def</span> <span class="nf">_removeOutliers</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">outlierConstant</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># print(a)</span>
    <span class="n">upper_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span>
    <span class="n">lower_quartile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="c1"># print(&#39;upper_quartile: &#39; + str(upper_quartile))</span>
    <span class="c1"># print(&#39;lower_quartile: &#39; + str(lower_quartile))</span>
    <span class="n">IQR</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_quartile</span> <span class="o">-</span> <span class="n">lower_quartile</span><span class="p">)</span> <span class="o">*</span> <span class="n">outlierConstant</span>
    <span class="n">quartileSet</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_quartile</span> <span class="o">-</span> <span class="n">IQR</span><span class="p">,</span> <span class="n">upper_quartile</span> <span class="o">+</span> <span class="n">IQR</span><span class="p">)</span>
    <span class="c1"># print(&quot;quartileSet: &quot; + str(quartileSet))</span>

    <span class="n">resultList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">iTrue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">quartileSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">quartileSet</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">resultList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">iTrue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># print(iTrue)</span>
    <span class="k">return</span> <span class="n">resultList</span><span class="p">,</span> <span class="n">iTrue</span><span class="p">,</span> <span class="n">quartileSet</span>


<span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Curve least square fit.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    *</span>

<span class="sd">    Returns:</span>

<span class="sd">    * Intersect y(0) (with the y-axis, useful for scalFUN function)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>  <span class="c1"># this is your &#39;straight line&#39; y=f(x)</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">B</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least 3 points to fit the data&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;rmvOutliers&quot;</span><span class="p">:</span>
                    <span class="c1"># print(x)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">filtered_entries</span><span class="p">,</span> <span class="n">quartileSet</span> <span class="o">=</span> <span class="n">_removeOutliers</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="c1"># print(&quot;------&quot;)</span>
                    <span class="c1"># print(filtered_entries)</span>
                    <span class="c1"># ------------------------------------ #</span>
                    <span class="c1"># print(&#39;remove outliers points&#39;)</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                    <span class="c1"># if np.mean(x)&lt;0:</span>
                    <span class="c1">#     filtered_entries = (x &lt; 0)</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     filtered_entries = (x &gt; 0)</span>
                    <span class="n">new_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">filtered_entries</span><span class="p">,</span> <span class="p">:]</span>

                    <span class="c1"># new_df = df[filtered_entries]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># ------------------------------------ #</span>

            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># your data x, y to fit</span>
            <span class="c1"># popt, pcov = curve_fit(f,x,y,loss=&#39;soft_l1&#39;) # your data x, y to fit</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># min/max values for x axis</span>

            <span class="c1"># x_min = quartileSet[0]</span>
            <span class="c1"># x_max = quartileSet[1]                               #min/max values for x axis</span>
            <span class="c1"># print(&#39;x_min: &#39; + str(x_min))</span>
            <span class="c1"># print(&#39;x_max: &#39; + str(x_max))</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;slope&quot;</span><span class="p">:</span>  <span class="c1"># prolongation until the curve intersect</span>
                    <span class="n">slope</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">if</span> <span class="n">slope</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_min_reg</span> <span class="o">=</span> <span class="n">x_min</span> <span class="o">+</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
                        <span class="n">x_max_reg</span> <span class="o">=</span> <span class="n">x_max</span>
                    <span class="k">if</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_min_reg</span> <span class="o">=</span> <span class="n">x_min</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_max</span>
                        <span class="n">x_max_reg</span> <span class="o">=</span> <span class="n">x_max</span>  <span class="c1"># + 2*np.abs(max(df[0][k[1]]))</span>

                    <span class="n">x_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="n">x_min_reg</span><span class="p">,</span> <span class="n">x_max_reg</span><span class="p">,</span> <span class="mi">100</span>
                    <span class="p">)</span>  <span class="c1"># range of x values used for the fit function</span>

                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;SI&quot;</span>
                <span class="p">):</span>  <span class="c1"># study of ridges intersection with the origin to infer the structural index</span>
                    <span class="n">fit_SI</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">if</span> <span class="n">fit_SI</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">x_min_SI</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">x_max_SI</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># min/max values for x axis</span>
                        <span class="n">x_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                            <span class="n">x_min_SI</span><span class="p">,</span> <span class="n">x_max_SI</span><span class="p">,</span> <span class="mi">100</span>
                        <span class="p">)</span>  <span class="c1"># range of x values used for the fit function</span>

            <span class="c1">#     if key == &#39;xmin&#39;:</span>
            <span class="c1">#        x_min = value</span>
            <span class="c1">#     if key == &#39;xmax&#39;:</span>
            <span class="c1">#        x_max = value</span>
            <span class="c1"># print(&#39;x_min_reg: &#39; + str(x_min_reg))</span>
            <span class="c1"># print(&#39;x_max_reg: &#39; + str(x_max_reg))</span>

            <span class="n">y_fit</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_fit</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

            <span class="c1"># evaluate function at y(0)</span>
            <span class="n">intersect</span> <span class="o">=</span> <span class="n">y_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can&#39;t fit this ridge - go to the next&quot;</span><span class="p">)</span>
            <span class="n">x_fit</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">y_fit</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">intersect</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">intersect</span>


<span class="k">def</span> <span class="nf">_ridges_2_df</span><span class="p">(</span><span class="n">RI_minmax</span><span class="p">,</span> <span class="n">RII_minmax</span><span class="p">,</span> <span class="n">RIII_minmax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># kwargs</span>
    <span class="c1"># prefix</span>

    <span class="n">dfI</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">RI_minmax</span><span class="p">)</span>
    <span class="c1"># df[0] = [&#39;layer&#39;]</span>
    <span class="n">dfI</span> <span class="o">=</span> <span class="n">dfI</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="s2">&quot;EX_xpos&quot;</span><span class="p">)</span>
    <span class="n">dfI</span> <span class="o">=</span> <span class="n">dfI</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;EX_xpos0&quot;</span><span class="p">:</span> <span class="s2">&quot;elevation&quot;</span><span class="p">})</span>
    <span class="n">dfI</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">dfII</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">RII_minmax</span><span class="p">)</span>
    <span class="c1"># df[0] = [&#39;layer&#39;]</span>
    <span class="n">dfII</span> <span class="o">=</span> <span class="n">dfII</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="s2">&quot;EX_xpos&quot;</span><span class="p">)</span>
    <span class="n">dfII</span> <span class="o">=</span> <span class="n">dfII</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;EX_xpos0&quot;</span><span class="p">:</span> <span class="s2">&quot;elevation&quot;</span><span class="p">})</span>
    <span class="n">dfII</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">dfIII</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">RIII_minmax</span><span class="p">)</span>
    <span class="c1"># df[0] = [&#39;layer&#39;]</span>
    <span class="n">dfIII</span> <span class="o">=</span> <span class="n">dfIII</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="s2">&quot;EX_xpos&quot;</span><span class="p">)</span>
    <span class="n">dfIII</span> <span class="o">=</span> <span class="n">dfIII</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;EX_xpos0&quot;</span><span class="p">:</span> <span class="s2">&quot;elevation&quot;</span><span class="p">})</span>
    <span class="n">dfIII</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dfI</span><span class="p">,</span> <span class="n">dfII</span><span class="p">,</span> <span class="n">dfIII</span>


<span class="k">def</span> <span class="nf">pad_edges</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">pad_type</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>

    <span class="n">padtypes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lintaper&quot;</span><span class="p">,</span>
        <span class="s2">&quot;reflection&quot;</span><span class="p">,</span>
        <span class="s2">&quot;oddreflection&quot;</span><span class="p">,</span>
        <span class="s2">&quot;oddreflectiontaper&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">yp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">padtype</span> <span class="o">=</span> <span class="n">padtypes</span><span class="p">[</span><span class="n">pad_type</span><span class="p">]</span>
    <span class="n">padded_data</span><span class="p">,</span> <span class="n">nps</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">pad_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="n">padtype</span><span class="p">)</span>
    <span class="c1"># Get coordinate vectors</span>
    <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span> <span class="o">=</span> <span class="n">gridder</span><span class="o">.</span><span class="n">pad_coords</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">],</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nps</span><span class="p">)</span>
    <span class="n">padshape</span> <span class="o">=</span> <span class="n">padded_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">padtype</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
        <span class="n">pad_y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">padshape</span><span class="p">),</span> <span class="n">pad_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">padshape</span><span class="p">),</span> <span class="n">padded_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdBu_r&quot;</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">pad_y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pad_y</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">pad_x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">pad_x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">padded_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">padded_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">pad_x</span>
    <span class="n">yp</span> <span class="o">=</span> <span class="n">pad_y</span>

    <span class="k">return</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">shape</span>


<div class="viewcode-block" id="profile_extra"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.profile_extra">[docs]</a><span class="k">def</span> <span class="nf">profile_extra</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a profile between 2 points from spacial data.</span>

<span class="sd">    Uses interpolation to calculate the data values at the profile points.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D arrays</span>
<span class="sd">        Arrays with the x and y coordinates of the data points.</span>
<span class="sd">    * v : 1D array</span>
<span class="sd">        Array with the scalar value assigned to the data points.</span>
<span class="sd">    * point1, point2 : lists = [x, y]</span>
<span class="sd">        Lists the x, y coordinates of the 2 points between which the profile</span>
<span class="sd">        will be extracted.</span>
<span class="sd">    * size : int</span>
<span class="sd">        Number of points along the profile.</span>
<span class="sd">    * algorithm : string</span>
<span class="sd">        Interpolation algorithm. Either ``&#39;cubic&#39;``, ``&#39;nearest&#39;``,</span>
<span class="sd">        ``&#39;linear&#39;`` (see scipy.interpolate.griddata).</span>

<span class="sd">    Returns:</span>

<span class="sd">    * [xp, yp, distances, vp] : 1d arrays</span>
<span class="sd">        ``xp`` and ``yp`` are the x, y coordinates of the points along the</span>
<span class="sd">        profile. ``distances`` are the distances of the profile points from</span>
<span class="sd">        ``point1``. ``vp`` are the data points along the profile.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="profile_noInter"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.profile_noInter">[docs]</a><span class="k">def</span> <span class="nf">profile_noInter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># https://stackoverflow.com/questions/7878398/how-to-extract-an-arbitrary-line-of-values-from-a-numpy-array</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a profile between 2 points from spacial data.</span>

<span class="sd">    NO interpolation to calculate the data values at the profile points (find nearest point).</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * x, y : 1D arrays</span>
<span class="sd">        Arrays with the x and y coordinates of the data points.</span>
<span class="sd">    * v : 1D array</span>
<span class="sd">        Array with the scalar value assigned to the data points.</span>
<span class="sd">    * point1, point2 : lists = [x, y]</span>
<span class="sd">        Lists the x, y coordinates of the 2 points between which the profile</span>
<span class="sd">        will be extracted.</span>
<span class="sd">    * size : int</span>
<span class="sd">        Number of points along the profile.</span>

<span class="sd">    Returns:</span>

<span class="sd">    * [xp, yp, distances, vp] : 1d arrays</span>
<span class="sd">        ``xp`` and ``yp`` are the x, y coordinates of the points along the</span>
<span class="sd">        profile. ``distances`` are the distances of the profile points from</span>
<span class="sd">        ``point1``. ``vp`` are the data points along the profile.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Xaxis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">showfig</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;Xaxis&quot;</span><span class="p">:</span>
            <span class="n">Xaxis</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;showfig&quot;</span><span class="p">:</span>
            <span class="n">showfig</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">point1</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">point2</span>
    <span class="n">maxdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxdist</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">distances</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">yp</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">distances</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;dist&quot;</span><span class="p">:</span>
        <span class="n">xaxis</span> <span class="o">=</span> <span class="n">distances</span>
    <span class="k">elif</span> <span class="n">Xaxis</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
        <span class="n">xaxis</span> <span class="o">=</span> <span class="n">xp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xaxis</span> <span class="o">=</span> <span class="n">yp</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">points_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># find nearest point</span>

    <span class="c1"># from progressbar import ProgressBar</span>
    <span class="c1"># pbar = ProgressBar()</span>
    <span class="c1"># vp = []</span>
    <span class="c1"># for p in pbar(points_p):</span>
    <span class="c1">#     ind = _closest_node(p, nodes)</span>
    <span class="c1">#     vp.append(v[ind])</span>

    <span class="c1"># from progressbar import ProgressBar</span>
    <span class="c1"># pbar = ProgressBar()</span>
    <span class="n">vp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_p</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">_closest_node</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="n">vp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

    <span class="n">vp_smooth_dict</span> <span class="o">=</span> <span class="n">_smooth_allfcts</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">showfig</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">vp_smooth_dict</span></div>


<span class="k">def</span> <span class="nf">_smooth_allfcts</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="c1"># window_size, poly_order = 101, 3</span>
    <span class="c1"># vp_smooth = savgol_filter(vp, window_size, poly_order)</span>
    <span class="c1"># print(xaxis)</span>
    <span class="c1"># spl = UnivariateSpline(xaxis, vp, s=10)</span>
    <span class="c1"># plt.plot(xaxis, spl(xaxis), &#39;g&#39;, lw=3)</span>
    <span class="c1"># vp_smooth_spline = np.array(spl(xaxis))</span>

    <span class="c1"># xaxis = distances</span>
    <span class="c1"># xnew = np.linspace(min(xaxis),</span>
    <span class="c1">#                 max(xaxis),len(x))</span>
    <span class="c1"># vp_smooth = gridder.interp_at(x, y, v, xp, yp, algorithm=&#39;cubic&#39;, extrapolate=True)</span>

    <span class="c1">#%%</span>
    <span class="c1"># _smooth_lowpass</span>

    <span class="c1">#%%</span>
    <span class="c1"># if smooth == True:</span>

    <span class="n">vp_smooth_0</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">)</span>

    <span class="n">vp_smooth_1</span> <span class="o">=</span> <span class="n">_smooth1d</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">)</span>
    <span class="n">vp_smooth_2</span> <span class="o">=</span> <span class="n">_smooth1d_old</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">)</span>
    <span class="n">vp_smooth_3</span> <span class="o">=</span> <span class="n">_smooth_lowpass</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_1</span><span class="p">)</span>

    <span class="c1"># f = interpolate.interp1d(xaxis, vp, fill_value=&#39;extrapolate&#39;,kind=&#39;cubic&#39;)</span>
    <span class="c1"># xnew = np.linspace(min(xaxis),</span>
    <span class="c1">#                     max(xaxis),len(xaxis))</span>
    <span class="c1"># vp_smooth_4 = f(xnew)</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vp_smooth_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">vp_smooth_4</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span>
        <span class="n">vp_smooth_2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">vp_smooth_2</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">showfig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;lowpass&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;hanning_window&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;hanning_window + lowpass&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;CubicSmoothingSpline&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">vp_smooth_4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;CubicSmoothingSpline + interp1d&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">vp_smooth_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Lowpass&quot;</span><span class="p">:</span> <span class="n">vp_smooth_0</span><span class="p">,</span>
        <span class="s2">&quot;Hanning&quot;</span><span class="p">:</span> <span class="n">vp_smooth_1</span><span class="p">,</span>
        <span class="s2">&quot;Hanning+Lowpass&quot;</span><span class="p">:</span> <span class="n">vp_smooth_3</span><span class="p">,</span>
        <span class="s2">&quot;CubicSmoothingSpline&quot;</span><span class="p">:</span> <span class="n">vp_smooth_2</span><span class="p">,</span>
        <span class="s2">&quot;CubicSmoothingSpline + interp1d&quot;</span><span class="p">:</span> <span class="n">vp_smooth_4</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">vp_smooth_dict</span>


<span class="k">def</span> <span class="nf">_closest_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">dist_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">nodes</span> <span class="o">-</span> <span class="n">node</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_2</span><span class="p">)</span>


<span class="c1"># ----- peaks detections</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">Inf</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">array</span>


<div class="viewcode-block" id="peakdet"><a class="viewcode-back" href="../content/api_core/api.html#dEXP.peakdet">[docs]</a><span class="k">def</span> <span class="nf">peakdet</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converted from MATLAB script at http://billauer.co.il/peakdet.html</span>

<span class="sd">    Returns two arrays</span>

<span class="sd">    function [maxtab, mintab]=peakdet(v, delta, x)</span>
<span class="sd">    %PEAKDET Detect peaks in a vector</span>
<span class="sd">    %        [MAXTAB, MINTAB] = PEAKDET(V, DELTA) finds the local</span>
<span class="sd">    %        maxima and minima (&quot;peaks&quot;) in the vector V.</span>
<span class="sd">    %        MAXTAB and MINTAB consists of two columns. Column 1</span>
<span class="sd">    %        contains indices in V, and column 2 the found values.</span>
<span class="sd">    %</span>
<span class="sd">    %        With [MAXTAB, MINTAB] = PEAKDET(V, DELTA, X) the indices</span>
<span class="sd">    %        in MAXTAB and MINTAB are replaced with the corresponding</span>
<span class="sd">    %        X-values.</span>
<span class="sd">    %</span>
<span class="sd">    %        A point is considered a maximum peak if it has the maximal</span>
<span class="sd">    %        value, and was preceded (to the left) by a value lower by</span>
<span class="sd">    %        DELTA.</span>

<span class="sd">    % Eli Billauer, 3.4.05 (Explicitly not copyrighted).</span>
<span class="sd">    % This function is released to the public domain; Any use is allowed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxtab</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mintab</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Input vectors v and x must have same length&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Input argument delta must be a scalar&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Input argument delta must be positive&quot;</span><span class="p">)</span>

    <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">Inf</span><span class="p">,</span> <span class="o">-</span><span class="n">Inf</span>
    <span class="n">mnpos</span><span class="p">,</span> <span class="n">mxpos</span> <span class="o">=</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">NaN</span>

    <span class="n">lookformax</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">this</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">this</span>
            <span class="n">mxpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">this</span> <span class="o">&lt;</span> <span class="n">mn</span><span class="p">:</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="n">this</span>
            <span class="n">mnpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lookformax</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">&lt;</span> <span class="n">mx</span> <span class="o">-</span> <span class="n">delta</span><span class="p">:</span>
                <span class="n">maxtab</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mxpos</span><span class="p">,</span> <span class="n">mx</span><span class="p">))</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">this</span>
                <span class="n">mnpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lookformax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">&gt;</span> <span class="n">mn</span> <span class="o">+</span> <span class="n">delta</span><span class="p">:</span>
                <span class="n">mintab</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mnpos</span><span class="p">,</span> <span class="n">mn</span><span class="p">))</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">this</span>
                <span class="n">mxpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lookformax</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maxtab</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mintab</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_smooth1d_old</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">csaps</span>

    <span class="n">spl</span> <span class="o">=</span> <span class="n">csaps</span><span class="o">.</span><span class="n">CubicSmoothingSpline</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span>
    <span class="c1"># spl = UnivariateSpline(x_axis, p_up, s=3)</span>
    <span class="c1"># spl.set_smoothing_factor(0.005)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spl</span><span class="p">(</span><span class="n">x_axis</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_smooth1d</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hanning&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.&quot;&quot;&quot;</span>

    <span class="c1"># from scipy.signal import savgol_filter</span>
    <span class="c1"># from scipy.interpolate import interp1d</span>

    <span class="c1"># itp = interp1d(x,y, kind=&#39;linear&#39;)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_up</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ws</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">ws</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">window_size</span><span class="p">,</span> <span class="n">poly_order</span> <span class="o">=</span> <span class="n">ws</span><span class="p">,</span> <span class="mi">2</span>
    <span class="n">filtdata</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">p_up</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtdata</span>


<span class="k">def</span> <span class="nf">_smooth_lowpass</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">p_up</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">cutoff</span> <span class="o">=</span> <span class="mf">0.015</span>  <span class="c1"># desired cutoff frequency of the filter, Hz ,      slightly higher than actual 1.2 Hz</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Filter requirements.</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># sample rate, Hz</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span>  <span class="c1"># Nyquist Frequency</span>
    <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># sin wave can be approx represented as quadratic</span>
    <span class="c1"># print(&#39;cutoff &#39;+ str(cutoff))</span>
    <span class="c1"># print(&#39;fs &#39;+ str(fs))</span>
    <span class="c1"># print(&#39;order &#39;+ str(order))</span>

    <span class="n">filtdata</span> <span class="o">=</span> <span class="n">butter_lowpass_filter</span><span class="p">(</span><span class="n">p_up</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">nyq</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtdata</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">butter_lowpass_filter</span><span class="p">(</span><span class="n">p_up</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">nyq</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">normal_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="n">nyq</span>
    <span class="c1"># Get the filter coefficients</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">normal_cutoff</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;low&quot;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p_up</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">smooth2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;square&quot;</span><span class="p">)</span>
    <span class="c1"># plt.show()</span>

    <span class="n">U2d</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
    <span class="n">U2d_f</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">U2d</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

    <span class="n">U_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
    <span class="n">U_f</span> <span class="o">=</span> <span class="n">U2d_f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">U_f</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;square&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">U_f</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Benjamin Mary.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>